<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ecosystem Evolution Simulation</title>
    <!-- TailwindCSS for rapid UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a cleaner typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Basic styling for the body and layout components */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevents scrollbars from appearing on the main page */
        }
        #simulation-container {
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block; /* Removes any default spacing below the canvas element */
        }
        .control-panel {
            background-color: #2d3748; /* Tailwind bg-gray-800 */
            border-radius: 0.5rem;
        }
        .stat-card {
             background-color: #4a5568; /* Tailwind bg-gray-700 */
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col md:flex-row h-screen antialiased">

    <!-- This main container will hold the 3D simulation canvas. It's designed to be flexible and take up remaining space. -->
    <div class="flex-grow relative" id="simulation-container">
        <!-- The Three.js canvas will be dynamically inserted here by the script. -->
    </div>

    <!-- This is the main panel for user controls and displaying statistics. It has a fixed width on larger screens. -->
    <div class="w-full md:w-80 lg:w-96 p-4 flex flex-col space-y-4 control-panel overflow-y-auto">
        <h1 class="text-2xl font-bold text-center text-green-400">EvoSim 3D</h1>
        <p class="text-center text-gray-400 text-sm">A Virtual Ecosystem in Motion</p>

        <!-- Simulation state controls (Start, Stop, Reset) -->
        <div class="space-y-2">
            <h2 class="text-lg font-semibold border-b border-gray-600 pb-1">Controls</h2>
            <div class="flex justify-around space-x-2">
                <button id="start-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105">Start</button>
                <button id="stop-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105">Stop</button>
            </div>
             <button id="reset-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105">Reset</button>
        </div>

        <!-- Real-time general statistics display -->
        <div class="space-y-2">
            <h2 class="text-lg font-semibold border-b border-gray-600 pb-1">Statistics</h2>
            <div class="stat-card p-3 rounded-lg">
                <p><strong>Time Elapsed:</strong> <span id="time-elapsed">0</span> ticks</p>
                <p><strong>Total Creatures:</strong> <span id="total-creatures">0</span></p>
                <p><strong>Food Available:</strong> <span id="food-count">0</span></p>
            </div>
        </div>

        <!-- Container for detailed stats for each species, updated in real-time. -->
        <div class="space-y-3">
             <h2 class="text-lg font-semibold border-b border-gray-600 pb-1">Species</h2>
             <div id="species-stats-container">
                <div class="stat-card p-3 rounded-lg mb-3">
                    <div class="flex items-center mb-2">
                       <div class="w-4 h-4 rounded-full" style="background-color: #A0A0A0;"></div><h3 class="font-bold text-gray-300 ml-2">Rabbits</h3>
                    </div>
                    <p><strong>Count:</strong> <span id="rabbit-count">0</span></p>
                    <p><strong>Avg. Speed:</strong> <span id="rabbit-speed">0</span></p>
                    <p><strong>Avg. Sense:</strong> <span id="rabbit-sense">0</span></p>
                </div>
                 <div class="stat-card p-3 rounded-lg mb-3">
                    <div class="flex items-center mb-2">
                       <div class="w-4 h-4 rounded-full" style="background-color: #E0E0E0;"></div><h3 class="font-bold text-gray-200 ml-2">Sheep</h3>
                    </div>
                    <p><strong>Count:</strong> <span id="sheep-count">0</span></p>
                    <p><strong>Avg. Speed:</strong> <span id="sheep-speed">0</span></p>
                    <p><strong>Avg. Sense:</strong> <span id="sheep-sense">0</span></p>
                </div>
                <div class="stat-card p-3 rounded-lg mb-3">
                     <div class="flex items-center mb-2">
                       <div class="w-4 h-4 rounded-full" style="background-color: #D46A34;"></div><h3 class="font-bold text-orange-400 ml-2">Foxes (Carnivore)</h3>
                    </div>
                    <p><strong>Count:</strong> <span id="fox-count">0</span></p>
                    <p><strong>Avg. Speed:</strong> <span id="fox-speed">0</span></p>
                    <p><strong>Avg. Sense:</strong> <span id="fox-sense">0</span></p>
                </div>
                 <div class="stat-card p-3 rounded-lg">
                     <div class="flex items-center mb-2">
                       <div class="w-4 h-4 rounded-full" style="background-color: #57C4E5;"></div><h3 class="font-bold text-cyan-300 ml-2">Birds (Omnivore)</h3>
                    </div>
                    <p><strong>Count:</strong> <span id="bird-count">0</span></p>
                    <p><strong>Avg. Speed:</strong> <span id="bird-speed">0</span></p>
                    <p><strong>Avg. Sense:</strong> <span id="bird-sense">0</span></p>
                </div>
             </div>
        </div>

        <!-- User-adjustable simulation parameters -->
        <div class="space-y-2">
            <h2 class="text-lg font-semibold border-b border-gray-600 pb-1">Parameters</h2>
            <div class="space-y-3 text-sm pt-2">
                 <div>
                    <label for="tick-duration">Tick Duration: <span id="tick-duration-value">33</span> ms</label>
                    <input type="range" id="tick-duration" min="16" max="250" value="33" class="w-full">
                </div>
                <div>
                    <label for="rabbit-start-count">Initial Rabbits: <span id="rabbit-start-count-value">25</span></label>
                    <input type="range" id="rabbit-start-count" min="0" max="100" value="25" class="w-full">
                </div>
                <div>
                    <label for="sheep-start-count">Initial Sheep: <span id="sheep-start-count-value">15</span></label>
                    <input type="range" id="sheep-start-count" min="0" max="100" value="15" class="w-full">
                </div>
                 <div>
                    <label for="fox-start-count">Initial Foxes: <span id="fox-start-count-value">10</span></label>
                    <input type="range" id="fox-start-count" min="0" max="50" value="10" class="w-full">
                </div>
                <div>
                    <label for="bird-start-count">Initial Birds: <span id="bird-start-count-value">15</span></label>
                    <input type="range" id="bird-start-count" min="0" max="50" value="15" class="w-full">
                </div>
                <div>
                    <label for="food-regen-rate">Food Regen Rate: <span id="food-regen-value">20</span></label>
                    <input type="range" id="food-regen-rate" min="1" max="100" value="20" class="w-full">
                </div>
                <div>
                    <label for="mutation-rate">Mutation Rate: <span id="mutation-rate-value">0.10</span></label>
                    <input type="range" id="mutation-rate" min="0" max="0.5" step="0.01" value="0.1" class="w-full">
                </div>
                 <div class="pt-2">
                    <label for="toggle-vision-cones" class="flex items-center cursor-pointer">
                        <input type="checkbox" id="toggle-vision-cones" class="h-4 w-4 rounded text-blue-500 focus:ring-blue-400" checked>
                        <span class="ml-2 text-white">Show Vision Cones</span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- The importmap is necessary to use modern ES6 module imports for three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // Import the necessary Three.js modules
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        document.addEventListener('DOMContentLoaded', () => {
            // --- UI Elements ---
            // Get references to all the HTML elements for later manipulation. This is more efficient than repeatedly querying the DOM.
            const startBtn = document.getElementById('start-btn');
            const stopBtn = document.getElementById('stop-btn');
            const resetBtn = document.getElementById('reset-btn');
            const timeElapsedEl = document.getElementById('time-elapsed');
            const totalCreaturesEl = document.getElementById('total-creatures');
            const foodCountEl = document.getElementById('food-count');
            // Species stats
            const rabbitCountEl = document.getElementById('rabbit-count');
            const rabbitSpeedEl = document.getElementById('rabbit-speed');
            const rabbitSenseEl = document.getElementById('rabbit-sense');
            const sheepCountEl = document.getElementById('sheep-count');
            const sheepSpeedEl = document.getElementById('sheep-speed');
            const sheepSenseEl = document.getElementById('sheep-sense');
            const foxCountEl = document.getElementById('fox-count');
            const foxSpeedEl = document.getElementById('fox-speed');
            const foxSenseEl = document.getElementById('fox-sense');
            const birdCountEl = document.getElementById('bird-count');
            const birdSpeedEl = document.getElementById('bird-speed');
            const birdSenseEl = document.getElementById('bird-sense');
            // Parameter inputs
            const tickDurationInput = document.getElementById('tick-duration');
            const foodRegenRateInput = document.getElementById('food-regen-rate');
            const mutationRateInput = document.getElementById('mutation-rate');
            const rabbitStartCountInput = document.getElementById('rabbit-start-count');
            const sheepStartCountInput = document.getElementById('sheep-start-count');
            const foxStartCountInput = document.getElementById('fox-start-count');
            const birdStartCountInput = document.getElementById('bird-start-count');
            const toggleVisionConesInput = document.getElementById('toggle-vision-cones');
            // Parameter value displays
            const tickDurationValueEl = document.getElementById('tick-duration-value');
            const foodRegenValueEl = document.getElementById('food-regen-value');
            const mutationRateValueEl = document.getElementById('mutation-rate-value');
            const rabbitStartCountValueEl = document.getElementById('rabbit-start-count-value');
            const sheepStartCountValueEl = document.getElementById('sheep-start-count-value');
            const foxStartCountValueEl = document.getElementById('fox-start-count-value');
            const birdStartCountValueEl = document.getElementById('bird-start-count-value');

            // --- Three.js Setup ---
            const container = document.getElementById('simulation-container');
            let scene, camera, renderer, controls;
            const clock = new THREE.Clock(); // Used for frame-rate independent updates.
            
            // --- Simulation State ---
            // These variables hold the core state of the simulation at any given moment.
            let simulationRunning = false; // Is the simulation currently updating?
            let time = 0;                  // How many ticks have passed.
            let creatures = [];            // An array holding all active creature objects.
            let food = [];                 // An array holding all active food objects.
            let elapsedSinceTick = 0;      // Time accumulator for controlling tick speed.
            
            // --- Configuration Object ---
            // This object centralizes all the tunable parameters for the ecosystem, making it easy to adjust the simulation's behavior.
            const config = {
                simulation: { tickDuration: 33 }, // Target time in ms for each simulation tick.
                world: { width: 800, depth: 800 }, // Size of the simulation area.
                food: { initialCount: 150, energy: 25, regenRate: 20 },
                rabbit: {
                    initialCount: 25, color: 0xA0A0A0, initialEnergy: 100, reproduceEnergy: 200, energyDecay: 0.15, size: 2.5,
                    initialSpeed: 1.5, initialSense: 70, fieldOfView: Math.PI / 2
                },
                 sheep: {
                    initialCount: 15, color: 0xE0E0E0, initialEnergy: 120, reproduceEnergy: 250, energyDecay: 0.2, size: 3.5,
                    initialSpeed: 1.2, initialSense: 60, fieldOfView: Math.PI / 2,
                    // Boids-specific parameters
                    flockRadius: 50,      // How far a sheep can see its flockmates.
                    separationWeight: 0.05, // How strongly a sheep avoids its neighbors.
                    alignmentWeight: 0.03,  // How strongly a sheep tries to match its neighbors' direction.
                    cohesionWeight: 0.01,   // How strongly a sheep is drawn to the center of its flock.
                },
                fox: {
                    initialCount: 4, color: 0xD46A34, initialEnergy: 120, reproduceEnergy: 250, energyDecay: 0.25, preyEnergyBonus: 80, size: 4,
                    initialSpeed: 1.8, initialSense: 100, fieldOfView: Math.PI / 1.5
                },
                bird: {
                    initialCount: 6, color: 0x57C4E5, initialEnergy: 100, reproduceEnergy: 180, energyDecay: 0.2, size: 3,
                    initialSpeed: 2.0, initialSense: 120, fieldOfView: Math.PI, preyEnergyBonus: 60,
                    cruiseAltitude: 50
                },
                mutation: { rate: 0.1, maxFactor: 0.2 } // Chance and magnitude of genetic mutation upon reproduction.
            };

            // --- Utility Functions ---
            const random = (min, max) => Math.random() * (max - min) + min;
            const distance2D = (a, b) => Math.sqrt((a.x - b.x) ** 2 + (a.z - b.z) ** 2);

            // --- 3D Scene Initialization ---
            // This function sets up the entire Three.js environment once when the page loads.
            function init3D() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a202c);
                
                camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(0, 150, 200);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(renderer.domElement);

                // OrbitControls allow the user to navigate the scene with their mouse.
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; // Makes the camera movement feel smoother.

                // Lighting is essential for seeing the 3D models.
                const ambientLight = new THREE.AmbientLight(0xcccccc, 1.5); // Provides soft, global light.
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // Simulates a distant light source like the sun.
                directionalLight.position.set(50, 100, 75);
                scene.add(directionalLight);

                // The ground plane for our ecosystem.
                const planeGeometry = new THREE.PlaneGeometry(config.world.width, config.world.depth);
                const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x2d3748, side: THREE.DoubleSide });
                const groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
                groundPlane.rotation.x = -Math.PI / 2; // Rotate the plane to be flat.
                scene.add(groundPlane);
                
                const grid = new THREE.GridHelper(config.world.width, 20, 0x4a5568, 0x4a5568);
                scene.add(grid);
            }

            // --- Model Creation Functions ---
            // These functions procedurally build 3D models from basic shapes. They return an Object3D.
            function createRabbitModel(color) {
                const rabbit = new THREE.Object3D();
                const bodyMat = new THREE.MeshStandardMaterial({ color });
                const bodyGeo = new THREE.BoxGeometry(4, 4, 6);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                rabbit.add(body);
                const headGeo = new THREE.BoxGeometry(3, 3, 3);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.set(0, 2.5, 4);
                rabbit.add(head);
                const earGeo = new THREE.BoxGeometry(1.5, 5, 1);
                const leftEar = new THREE.Mesh(earGeo, bodyMat);
                leftEar.position.set(-1.5, 3, 4.5);
                rabbit.add(leftEar);
                const rightEar = new THREE.Mesh(earGeo, bodyMat);
                rightEar.position.set(1.5, 3, 4.5);
                rabbit.add(rightEar);
                return rabbit;
            }

            function createSheepModel() {
                const sheep = new THREE.Object3D();
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 }); // Wool
                const headMat = new THREE.MeshStandardMaterial({ color: 0x444444 }); // Face/Legs
                
                const bodyGeo = new THREE.IcosahedronGeometry(5, 0);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 3;
                sheep.add(body);

                const headGeo = new THREE.BoxGeometry(3, 3, 4);
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.set(0, 3, 5);
                sheep.add(head);

                const legGeo = new THREE.CylinderGeometry(0.8, 0.8, 4, 6);
                const leg1 = new THREE.Mesh(legGeo, headMat); leg1.position.set(2, -1, 2.5); sheep.add(leg1);
                const leg2 = new THREE.Mesh(legGeo, headMat); leg2.position.set(-2, -1, 2.5); sheep.add(leg2);
                const leg3 = new THREE.Mesh(legGeo, headMat); leg3.position.set(2, -1, -2.5); sheep.add(leg3);
                const leg4 = new THREE.Mesh(legGeo, headMat); leg4.position.set(-2, -1, -2.5); sheep.add(leg4);

                return sheep;
            }

            function createFoxModel(color) {
                const fox = new THREE.Object3D();
                const bodyMat = new THREE.MeshStandardMaterial({ color });
                const tailMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const bodyGeo = new THREE.BoxGeometry(5, 4, 8);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                fox.add(body);
                const headGeo = new THREE.ConeGeometry(2.5, 4, 4);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.rotation.z = Math.PI / 2;
                head.position.set(0, 1, 5);
                fox.add(head);
                const tailGeo = new THREE.ConeGeometry(1.5, 6, 8);
                const tail = new THREE.Mesh(tailGeo, bodyMat);
                tail.rotation.x = -Math.PI/4;
                tail.position.set(0, 0, -6);
                const tailTip = new THREE.Mesh(new THREE.ConeGeometry(1,2,8), tailMat);
                tailTip.position.y = -2.5;
                tail.add(tailTip);
                fox.add(tail);
                return fox;
            }

            function createBirdModel(color) {
                const bird = new THREE.Object3D();
                const bodyMat = new THREE.MeshStandardMaterial({ color });
                const bodyGeo = new THREE.BoxGeometry(2, 2, 5);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                bird.add(body);
                const wingGeo = new THREE.BoxGeometry(8, 0.5, 3);
                const leftWing = new THREE.Mesh(wingGeo, bodyMat);
                leftWing.position.set(-5, 0, 0);
                bird.add(leftWing);
                const rightWing = new THREE.Mesh(wingGeo, bodyMat);
                rightWing.position.set(5, 0, 0);
                bird.add(rightWing);
                return bird;
            }
            
            function createVegetationModel() {
                const vegetation = new THREE.Object3D();
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const leavesMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });

                if (Math.random() > 0.4) {
                    const trunkHeight = random(12, 18);
                    const trunkGeo = new THREE.CylinderGeometry(random(1.5, 2), random(2, 2.5), trunkHeight, 8);
                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                    trunk.position.y = trunkHeight / 2;
                    vegetation.add(trunk);
                    const leavesGeo = new THREE.IcosahedronGeometry(random(8, 12), 0);
                    const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                    leaves.position.y = trunkHeight + 3;
                    vegetation.add(leaves);
                } else {
                    const bushRadius = random(6, 9);
                    const leavesGeo = new THREE.IcosahedronGeometry(bushRadius, 0);
                    const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                    leaves.position.y = bushRadius / 2;
                    vegetation.add(leaves);
                }
                return vegetation;
            }

            // --- Classes ---
            // The base class for all creatures in the simulation, containing shared properties and methods.
            class Creature {
                 constructor(x, y, z, energy, speciesConfig, model) {
                    // Core properties
                    this.id = Math.random();
                    this.x = x; this.y = y; this.z = z;
                    this.energy = energy;
                    // Velocity vectors for movement
                    this.vx = random(-1, 1); this.vy = 0; this.vz = random(-1, 1);
                    // Species-specific configuration
                    this.config = speciesConfig;
                    this.size = this.config.size;
                    this.speed = this.config.initialSpeed;
                    this.sense = this.config.initialSense;

                    // --- 3D Representation ---
                    // A parent Object3D holds all parts of the creature. This is key for unified movement and rotation.
                    this.mesh = new THREE.Object3D();
                    this.mesh.position.set(this.x, this.y, this.z);
                    scene.add(this.mesh);

                    // The visible model is a child of the main mesh.
                    this.bodyModel = model;
                    this.bodyModel.scale.set(this.size * 0.5, this.size * 0.5, this.size * 0.5);
                    this.mesh.add(this.bodyModel);

                    // The vision cone is also a child, so it rotates with the parent mesh.
                    const coneGeo = new THREE.ConeGeometry(this.sense * 0.4, this.sense, 16, 1, true);
                    coneGeo.translate(0, -this.sense / 2, 0); // Anchors the tip of the cone to the creature's center.
                    const coneMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.05, side: THREE.DoubleSide });
                    this.visionCone = new THREE.Mesh(coneGeo, coneMat);
                    this.visionCone.rotation.x = -Math.PI / 2; // Points the cone forward.
                    this.visionCone.visible = toggleVisionConesInput.checked; 
                    this.mesh.add(this.visionCone);
                }
                
                // Handles the movement physics for the creature.
                move() {
                    this.energy -= this.config.energyDecay;
                    
                    // Normalize the velocity vector to maintain consistent speed regardless of direction.
                    const mag = Math.sqrt(this.vx**2 + this.vz**2);
                    if (mag > 0) { this.vx /= mag; this.vz /= mag; }

                    // Update position based on velocity and speed.
                    this.x += this.vx * this.speed;
                    this.z += this.vz * this.speed;

                    // World boundary collision check.
                    const halfWidth = config.world.width / 2;
                    const halfDepth = config.world.depth / 2;
                    if (this.x < -halfWidth || this.x > halfWidth) { this.vx *= -1; this.x = Math.max(-halfWidth, Math.min(this.x, halfWidth)); }
                    if (this.z < -halfDepth || this.z > halfDepth) { this.vz *= -1; this.z = Math.max(-halfDepth, Math.min(this.z, halfDepth)); }
                    
                    // Update the 3D model's position and orientation.
                    this.mesh.position.set(this.x, this.y, this.z);
                    this.mesh.lookAt(new THREE.Vector3(this.x + this.vx, this.y + this.vy, this.z + this.vz));
                }
                
                // Checks if a target is within the creature's cone of vision.
                isTargetInSight(target) {
                    const creatureDirection = new THREE.Vector3();
                    this.mesh.getWorldDirection(creatureDirection);
                    const toTarget = new THREE.Vector3(target.x - this.x, target.y - this.y, target.z - this.z);
                    const d = toTarget.length();
                    if (d > this.sense || d === 0) return false;
                    toTarget.normalize();
                    const angle = creatureDirection.angleTo(toTarget);
                    return angle < this.config.fieldOfView / 2;
                }
                
                // Handles reproduction if the creature has enough energy.
                reproduce() {
                    if (this.energy >= this.config.reproduceEnergy) {
                        this.energy /= 2;
                        const offspring = new this.constructor(this.x, this.y, this.z, this.energy);

                        // Apply mutations to offspring.
                        if (Math.random() < config.mutation.rate) {
                            offspring.speed *= (1 + random(-config.mutation.maxFactor, config.mutation.maxFactor));
                            offspring.speed = Math.max(0.5, offspring.speed);
                        }
                        if (Math.random() < config.mutation.rate) {
                            offspring.sense *= (1 + random(-config.mutation.maxFactor, config.mutation.maxFactor));
                            offspring.sense = Math.max(10, offspring.sense);
                            // Recreate the vision cone with the new sense value.
                            offspring.visionCone.geometry.dispose();
                            const newConeGeo = new THREE.ConeGeometry(offspring.sense * 0.4, offspring.sense, 16, 1, true);
                            newConeGeo.translate(0, -offspring.sense / 2, 0); 
                            offspring.visionCone.geometry = newConeGeo;
                        }
                        creatures.push(offspring);
                    }
                }
                
                // Cleanly removes the creature and its 3D model from the scene to prevent memory leaks.
                dispose() {
                     scene.remove(this.mesh);
                     while(this.mesh.children.length > 0){ 
                        const child = this.mesh.children[0];
                        this.mesh.remove(child);
                        if(child.geometry) child.geometry.dispose();
                        if(child.material) child.material.dispose();
                         while(child.children.length > 0) {
                            const subChild = child.children[0];
                             child.remove(subChild);
                             if(subChild.geometry) subChild.geometry.dispose();
                             if(subChild.material) subChild.material.dispose();
                         }
                    }
                }
            }

            // --- Species-Specific Classes ---
            class Rabbit extends Creature {
                constructor(x, y, z, energy) { 
                    super(x, y, z, energy, config.rabbit, createRabbitModel(config.rabbit.color)); 
                    this.type = 'rabbit'; 
                }
                update() {
                    let closestFood = null, minDistance = Infinity;
                    for (const f of food) {
                        if (this.isTargetInSight(f)) {
                           const d = distance2D(this, f);
                           if (d < minDistance) { minDistance = d; closestFood = f; }
                        }
                    }
                    if (closestFood) {
                        this.vx = (closestFood.x - this.x);
                        this.vz = (closestFood.z - this.z);
                    } else {
                        this.vx += random(-0.2, 0.2); 
                        this.vz += random(-0.2, 0.2);
                    }
                    this.move();
                    if (closestFood && distance2D(this, closestFood) < this.size * 2) {
                        this.energy += config.food.energy;
                        closestFood.dispose();
                        food = food.filter(f => f.id !== closestFood.id);
                    }
                    this.reproduce();
                }
            }
            
            class Sheep extends Creature {
                 constructor(x, y, z, energy) { 
                    super(x, y, z, energy, config.sheep, createSheepModel()); 
                    this.type = 'sheep'; 
                }
                
                // Boids flocking algorithm implementation
                flock() {
                    let separation = new THREE.Vector2(); // Steer to avoid crowding
                    let alignment = new THREE.Vector2();  // Steer towards the average heading of local flockmates
                    let cohesion = new THREE.Vector2();    // Steer to move toward the average position of local flockmates
                    let neighborCount = 0;

                    for(const other of creatures) {
                        if (other !== this && other.type === 'sheep') {
                            let d = distance2D(this, other);
                            if (d > 0 && d < this.config.flockRadius) {
                                // Separation
                                let diff = new THREE.Vector2(this.x - other.x, this.z - other.z);
                                diff.normalize();
                                diff.divideScalar(d);
                                separation.add(diff);
                                // Alignment
                                alignment.add(new THREE.Vector2(other.vx, other.vz));
                                // Cohesion
                                cohesion.add(new THREE.Vector2(other.x, other.z));
                                neighborCount++;
                            }
                        }
                    }

                    if (neighborCount > 0) {
                        alignment.divideScalar(neighborCount);
                        cohesion.divideScalar(neighborCount);
                        cohesion.sub(new THREE.Vector2(this.x, this.z));
                    }
                    return { separation, alignment, cohesion };
                }

                // Sheep's main update combines flocking behavior with food-seeking.
                update() {
                    let closestFood = null, minDistance = Infinity;
                    for (const f of food) {
                        if (this.isTargetInSight(f)) {
                           const d = distance2D(this, f);
                           if (d < minDistance) { minDistance = d; closestFood = f; }
                        }
                    }

                    const { separation, alignment, cohesion } = this.flock();
                    
                    separation.multiplyScalar(this.config.separationWeight);
                    alignment.multiplyScalar(this.config.alignmentWeight);
                    cohesion.multiplyScalar(this.config.cohesionWeight);

                    this.vx += separation.x + alignment.x + cohesion.x;
                    this.vz += separation.y + alignment.y + cohesion.y;
                    
                    if (closestFood) {
                        this.vx += (closestFood.x - this.x) * 0.05;
                        this.vz += (closestFood.z - this.z) * 0.05;
                    } else {
                        this.vx += random(-0.2, 0.2); 
                        this.vz += random(-0.2, 0.2);
                    }

                    this.move();
                    if (closestFood && distance2D(this, closestFood) < this.size * 2) {
                        this.energy += config.food.energy;
                        closestFood.dispose();
                        food = food.filter(f => f.id !== closestFood.id);
                    }
                    this.reproduce();
                }
            }

            class Fox extends Creature {
                constructor(x, y, z, energy) { 
                    super(x, y, z, energy, config.fox, createFoxModel(config.fox.color));
                    this.type = 'fox'; 
                }
                update() {
                    let closestPrey = null, minDistance = Infinity;
                    for (const c of creatures) {
                        if ( (c.type === 'rabbit' || c.type === 'sheep' || (c.type === 'bird' && c.y < 5)) && this.isTargetInSight(c)) {
                             const d = distance2D(this, c);
                             if (d < minDistance) { minDistance = d; closestPrey = c; }
                        }
                    }
                    
                    if (closestPrey) {
                         this.vx = (closestPrey.x - this.x);
                         this.vz = (closestPrey.z - this.z);
                    } else {
                         this.vx += random(-0.2, 0.2); 
                         this.vz += random(-0.2, 0.2);
                    }

                    this.move();
                    if (closestPrey && distance2D(this, closestPrey) < this.size * 2) {
                        this.energy += this.config.preyEnergyBonus + closestPrey.energy * 0.5;
                        closestPrey.dispose();
                        creatures = creatures.filter(c => c.id !== closestPrey.id);
                    }
                    this.reproduce();
                }
            }

            class Bird extends Creature {
                constructor(x, y, z, energy) {
                    super(x, y, z, energy, config.bird, createBirdModel(config.bird.color));
                    this.type = 'bird';
                    this.state = 'cruising';
                    this.target = null;
                }

                update() {
                    let closestTarget = null;
                    let minDistance = Infinity;

                    for (const c of creatures) {
                        if ((c.type === 'rabbit' || c.type === 'sheep') && this.isTargetInSight(c)) {
                            const d = distance2D(this, c);
                            if (d < minDistance) { minDistance = d; closestTarget = c; }
                        }
                    }
                     for (const f of food) {
                        if (this.isTargetInSight(f)) {
                           const d = distance2D(this, f);
                           if (d < minDistance) { minDistance = d; closestTarget = f; }
                        }
                    }

                    if (this.state === 'cruising') {
                        if(closestTarget) { this.state = 'diving'; this.target = closestTarget; }
                        this.vy = (config.bird.cruiseAltitude - this.y) * 0.05;
                    } else if (this.state === 'diving') {
                        if (!this.target || this.target.energy <= 0 || (!creatures.includes(this.target) && !food.includes(this.target))) {
                            this.state = 'cruising'; this.target = null;
                        } else {
                            this.vy = (0 - this.y) * 0.1;
                            if(this.y < 5) { this.state = 'eating'; }
                        }
                    } else if (this.state === 'eating') {
                        if(!this.target || distance2D(this, this.target) > this.size * 2) {
                            this.state = 'cruising'; this.target = null;
                        } else {
                            if (this.target.type) { // It's a creature
                                this.energy += this.config.preyEnergyBonus + this.target.energy * 0.5;
                                creatures = creatures.filter(c => c.id !== this.target.id);
                            } else { // It's food
                                this.energy += config.food.energy;
                                food = food.filter(f => f.id !== this.target.id);
                            }
                            this.target.dispose();
                            this.state = 'cruising'; this.target = null;
                        }
                    }
                    
                    this.y += this.vy;
                    
                    if (this.target) {
                        this.vx = (this.target.x - this.x);
                        this.vz = (this.target.z - this.z);
                    } else {
                        this.vx += random(-0.2, 0.2); 
                        this.vz += random(-0.2, 0.2);
                    }
                    
                    this.move();
                    this.reproduce();
                }
            }

            class Food {
                 constructor(x, z) {
                    this.x = x; this.y = 0; this.z = z;
                    this.id = Math.random();
                    this.mesh = createVegetationModel();
                    this.mesh.position.set(this.x, 0, this.z);
                    scene.add(this.mesh);
                 }
                 dispose() {
                    scene.remove(this.mesh);
                    while(this.mesh.children.length > 0){ 
                        const child = this.mesh.children[0];
                        this.mesh.remove(child);
                        if(child.geometry) child.geometry.dispose();
                        if(child.material) child.material.dispose();
                    }
                 }
            }
            
            // --- Core Simulation Functions ---
            // Initializes or resets the simulation to its starting state.
            function setup() {
                creatures.forEach(c => c.dispose());
                food.forEach(f => f.dispose());

                time = 0; creatures = []; food = [];
                const halfW = config.world.width / 2, halfD = config.world.depth / 2;

                for (let i = 0; i < config.food.initialCount; i++) { spawnFood(); }
                for (let i = 0; i < config.rabbit.initialCount; i++) {
                    creatures.push(new Rabbit(random(-halfW, halfD), 0, random(-halfW, halfD), config.rabbit.initialEnergy));
                }
                for (let i = 0; i < config.sheep.initialCount; i++) {
                    creatures.push(new Sheep(random(-halfW, halfD), 0, random(-halfW, halfD), config.sheep.initialEnergy));
                }
                for (let i = 0; i < config.fox.initialCount; i++) {
                    creatures.push(new Fox(random(-halfW, halfD), 0, random(-halfW, halfD), config.fox.initialEnergy));
                }
                for (let i = 0; i < config.bird.initialCount; i++) {
                    creatures.push(new Bird(random(-halfW, halfD), config.bird.cruiseAltitude, random(-halfW, halfD), config.bird.initialEnergy));
                }

                updateStats();
            }

            function spawnFood() {
                 const halfW = config.world.width / 2, halfD = config.world.depth / 2;
                 food.push(new Food(random(-halfW, halfD), random(-halfW, halfD)));
            }
            
            // The main animation loop, which is called every frame.
            function animate() {
                requestAnimationFrame(animate); // Schedules the next frame.
                controls.update(); // Updates camera controls.

                if (simulationRunning) {
                    elapsedSinceTick += clock.getDelta() * 1000; // Measures time since last frame.

                    // If enough time has passed, run one or more simulation ticks.
                    if (elapsedSinceTick > config.simulation.tickDuration) {
                        const ticksToRun = Math.floor(elapsedSinceTick / config.simulation.tickDuration);
                        for(let i = 0; i < ticksToRun; i++) {
                            time++;
                            if (time % Math.floor(100 / config.food.regenRate) === 0) { spawnFood(); }
                            // The core logic update for all creatures.
                            creatures.forEach(c => c.update());
                            // Remove dead creatures.
                            const deadCreatures = creatures.filter(c => c.energy <= 0);
                            deadCreatures.forEach(c => c.dispose());
                            creatures = creatures.filter(c => c.energy > 0);
                        }
                        elapsedSinceTick %= config.simulation.tickDuration; // Reset accumulator.
                        updateStats(); // Update the UI panel.
                    }
                } else {
                    clock.getDelta();
                    elapsedSinceTick = 0;
                }
                renderer.render(scene, camera); // Renders the 3D scene.
            }

            // Updates the statistics panel with current data.
            function updateStats() {
                let rabbitCount = 0, sheepCount = 0, foxCount = 0, birdCount = 0;
                let totalRabbitSpeed = 0, totalRabbitSense = 0, totalSheepSpeed = 0, totalSheepSense = 0,
                    totalFoxSpeed = 0, totalFoxSense = 0, totalBirdSpeed = 0, totalBirdSense = 0;

                creatures.forEach(c => {
                    switch(c.type) {
                        case 'rabbit': rabbitCount++; totalRabbitSpeed += c.speed; totalRabbitSense += c.sense; break;
                        case 'sheep': sheepCount++; totalSheepSpeed += c.speed; totalSheepSense += c.sense; break;
                        case 'fox': foxCount++; totalFoxSpeed += c.speed; totalFoxSense += c.sense; break;
                        case 'bird': birdCount++; totalBirdSpeed += c.speed; totalBirdSense += c.sense; break;
                    }
                });
                timeElapsedEl.textContent = time; totalCreaturesEl.textContent = creatures.length; foodCountEl.textContent = food.length;
                
                rabbitCountEl.textContent = rabbitCount;
                rabbitSpeedEl.textContent = rabbitCount > 0 ? (totalRabbitSpeed / rabbitCount).toFixed(2) : 'N/A';
                rabbitSenseEl.textContent = rabbitCount > 0 ? (totalRabbitSense / rabbitCount).toFixed(2) : 'N/A';

                sheepCountEl.textContent = sheepCount;
                sheepSpeedEl.textContent = sheepCount > 0 ? (totalSheepSpeed / sheepCount).toFixed(2) : 'N/A';
                sheepSenseEl.textContent = sheepCount > 0 ? (totalSheepSense / sheepCount).toFixed(2) : 'N/A';

                foxCountEl.textContent = foxCount;
                foxSpeedEl.textContent = foxCount > 0 ? (totalFoxSpeed / foxCount).toFixed(2) : 'N/A';
                foxSenseEl.textContent = foxCount > 0 ? (totalFoxSense / foxCount).toFixed(2) : 'N/A';

                birdCountEl.textContent = birdCount;
                birdSpeedEl.textContent = birdCount > 0 ? (totalBirdSpeed / birdCount).toFixed(2) : 'N/A';
                birdSenseEl.textContent = birdCount > 0 ? (totalBirdSense / birdCount).toFixed(2) : 'N/A';
            }
            
            // --- Event Listeners ---
            // These connect the UI elements (buttons, sliders) to their respective functions.
            startBtn.addEventListener('click', () => { if (!simulationRunning) { simulationRunning = true; startBtn.textContent = 'Running...'; startBtn.classList.add('opacity-50', 'cursor-not-allowed'); stopBtn.classList.remove('opacity-50', 'cursor-not-allowed'); } });
            stopBtn.addEventListener('click', () => { if (simulationRunning) { simulationRunning = false; startBtn.textContent = 'Resume'; startBtn.classList.remove('opacity-50', 'cursor-not-allowed'); stopBtn.classList.add('opacity-50', 'cursor-not-allowed'); } });
            resetBtn.addEventListener('click', () => { simulationRunning = false; startBtn.textContent = 'Start'; startBtn.classList.remove('opacity-50', 'cursor-not-allowed'); stopBtn.classList.add('opacity-50', 'cursor-not-allowed'); setup(); });
            
            tickDurationInput.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                config.simulation.tickDuration = value;
                tickDurationValueEl.textContent = value;
            });
            toggleVisionConesInput.addEventListener('change', (e) => {
                const isVisible = e.target.checked;
                creatures.forEach(c => {
                    if (c.visionCone) {
                        c.visionCone.visible = isVisible;
                    }
                });
            });
            rabbitStartCountInput.addEventListener('input', (e) => { const value = parseInt(e.target.value); config.rabbit.initialCount = value; rabbitStartCountValueEl.textContent = value; });
            sheepStartCountInput.addEventListener('input', (e) => { const value = parseInt(e.target.value); config.sheep.initialCount = value; sheepStartCountValueEl.textContent = value; });
            foxStartCountInput.addEventListener('input', (e) => { const value = parseInt(e.target.value); config.fox.initialCount = value; foxStartCountValueEl.textContent = value; });
            birdStartCountInput.addEventListener('input', (e) => { const value = parseInt(e.target.value); config.bird.initialCount = value; birdStartCountValueEl.textContent = value; });
            foodRegenRateInput.addEventListener('input', (e) => { const value = parseInt(e.target.value); config.food.regenRate = value; foodRegenValueEl.textContent = value; });
            mutationRateInput.addEventListener('input', (e) => { const value = parseFloat(e.target.value); config.mutation.rate = value; mutationRateValueEl.textContent = value.toFixed(2); });
            window.addEventListener('resize', () => { camera.aspect = container.clientWidth / container.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(container.clientWidth, container.clientHeight); });
            
            // --- Initial Setup ---
            // These lines ensure the UI sliders match the default values in the config object when the page first loads.
            tickDurationInput.value = config.simulation.tickDuration;
            tickDurationValueEl.textContent = config.simulation.tickDuration;
            rabbitStartCountInput.value = config.rabbit.initialCount; rabbitStartCountValueEl.textContent = config.rabbit.initialCount;
            sheepStartCountInput.value = config.sheep.initialCount; sheepStartCountValueEl.textContent = config.sheep.initialCount;
            foxStartCountInput.value = config.fox.initialCount; foxStartCountValueEl.textContent = config.fox.initialCount;
            birdStartCountInput.value = config.bird.initialCount; birdStartCountValueEl.textContent = config.bird.initialCount;
            foodRegenRateInput.value = config.food.regenRate; foodRegenValueEl.textContent = config.food.regenRate;
            mutationRateInput.value = config.mutation.rate; mutationRateValueEl.textContent = config.mutation.rate.toFixed(2);
            
            // --- Start the Simulation ---
            init3D();
            setup();
            animate();
        });
    </script>
</body>
</html>
